AkHQ: http://localhost:8085

SWAGGER: http://localhost:8082/swagger-ui/index.html#/send-controller/send

RABBIT MQ: http://localhost:15672
______________________________________________
Em sistemas baseados em Kafka, o consumo de mensagens não implica na remoção dos eventos do tópico. O Kafka funciona como um log distribuído e imutável, no qual as mensagens são armazenadas de forma sequencial e permanecem disponíveis até que sejam removidas por políticas de retenção previamente configuradas, como tempo máximo de armazenamento ou limite de espaço em disco. O papel do consumidor, portanto, não é apagar mensagens, mas sim manter o controle do seu progresso de leitura por meio do offset associado a um consumer group.

Cada consumer group possui seu próprio offset, que indica até qual mensagem o grupo já processou em cada partição do tópico. À medida que a aplicação consome mensagens com sucesso, esse offset é atualizado, avançando no log. O conjunto de mensagens que ainda não foi processado por um consumer group é conhecido como consumer lag, calculado como a diferença entre o último offset disponível no tópico e o offset atual do grupo. É esse lag que normalmente é monitorado em ferramentas como Grafana, onde costuma aparecer como “mensagens disponíveis” ou “eventos pendentes”, diminuindo conforme a aplicação consome os dados.

Essa distinção explica por que, em interfaces administrativas como AKHQ ou Kafdrop, é possível visualizar um número elevado de mensagens armazenadas em um tópico mesmo quando o lag do consumer group é zero. Nessas interfaces, o foco está no histórico do log mantido pelo Kafka, enquanto as métricas exibidas em dashboards operacionais estão orientadas à saúde do consumo e à capacidade da aplicação de acompanhar o volume de eventos produzidos. Assim, a redução do número de mensagens “disponíveis” observada no Grafana não representa a exclusão dos eventos, mas sim o avanço do offset do consumer group.

O crescimento do armazenamento em Kafka é controlado exclusivamente pelas políticas de retenção configuradas em cada tópico. O Kafka remove dados antigos de forma automática e eficiente, apagando segmentos inteiros do log quando os limites de tempo ou tamanho são atingidos, independentemente de as mensagens terem sido consumidas ou não. Esse modelo permite que múltiplos consumer groups processem os mesmos dados de maneira independente, possibilitando reprocessamento, auditoria e diferentes visões de consumo sobre o mesmo fluxo de eventos, sem impacto direto no armazenamento além do que foi definido pela retenção.

Dessa forma, Kafka se posiciona como um mecanismo de transporte e retenção temporária de eventos, e não como um repositório permanente de dados. Em arquiteturas maduras, ele atua como o backbone de eventos, enquanto sistemas de armazenamento de longo prazo, como bancos de dados ou data lakes, são responsáveis pela persistência definitiva das informações. Esse desacoplamento entre produção, consumo e retenção é o que permite ao Kafka escalar de forma previsível e confiável, mesmo em cenários de alto volume de eventos.

________________________________________________________________________

Kafka e filas tradicionais resolvem o mesmo problema geral — comunicação assíncrona entre sistemas —, porém partem de modelos conceituais completamente diferentes. Uma fila tradicional, como as encontradas em sistemas de mensageria clássicos, é baseada em consumo destrutivo: cada mensagem existe apenas até ser consumida por um consumidor. Quando um consumidor lê uma mensagem com sucesso, ela é removida da fila e deixa de estar disponível para outros consumidores. Esse modelo estabelece uma relação direta entre produção e consumo, na qual a mensagem representa uma unidade de trabalho que precisa ser processada exatamente uma vez por algum consumidor.

No Kafka, o modelo é o de um log distribuído e imutável. As mensagens são gravadas em tópicos e permanecem armazenadas independentemente de serem consumidas ou não. O consumo não altera o conteúdo do tópico; em vez disso, cada consumidor ou grupo de consumidores mantém seu próprio estado de leitura por meio de offsets. Isso permite que múltiplos consumidores leiam os mesmos eventos de forma independente, em ritmos diferentes, sem interferirem uns nos outros. O Kafka não trata mensagens como tarefas descartáveis, mas como eventos que representam fatos ocorridos no sistema.

Outra diferença fundamental está no controle de estado. Em filas tradicionais, o estado é centralizado no broker: ele precisa saber quais mensagens já foram entregues e quais ainda estão pendentes. No Kafka, o estado é descentralizado e pertence ao consumidor, que controla seu próprio offset. Essa inversão reduz o acoplamento entre o broker e as aplicações, permitindo maior escalabilidade e facilitando cenários como reprocessamento, replay de eventos e criação de novos consumidores que precisam ler dados históricos.

Em termos de escalabilidade e desempenho, filas tradicionais costumam ser otimizadas para garantir entrega confiável de mensagens individuais, com foco em baixa latência e controle rigoroso de acknowledgments. Já o Kafka foi projetado para alto throughput, trabalhando com escrita e leitura sequenciais em disco e processamento em lote, o que o torna especialmente eficiente para grandes volumes de eventos contínuos. Por isso, Kafka é amplamente utilizado como backbone de eventos em arquiteturas orientadas a eventos e pipelines de dados.

Por fim, a retenção de mensagens também reflete essa diferença de filosofia. Em filas, as mensagens vivem apenas até serem processadas; no Kafka, elas vivem de acordo com políticas de retenção configuradas, independentemente do consumo. Isso transforma o Kafka em uma fonte confiável de verdade temporal dos eventos do sistema, enquanto filas tradicionais funcionam como mecanismos de distribuição de trabalho.

Em resumo, filas são ideais quando o objetivo é distribuir tarefas pontuais que devem ser processadas uma única vez, enquanto o Kafka é mais adequado quando os eventos precisam ser preservados, reprocessados, auditados ou consumidos por múltiplos sistemas de forma desacoplada. Essa diferença de modelo é o que faz Kafka não ser “uma fila melhor”, mas sim uma categoria distinta de sistema de mensageria.